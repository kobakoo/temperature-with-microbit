{"files":{"pxt.json":"{\n    \"name\": \"microbit-pxt-timeanddate\",\n    \"version\": \"2.0.33\",\n    \"description\": \"Software based Real-Time Clock (Time & Date)\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"timeanddate.ts\",\n        \"timeanddate.cpp\",\n        \"shims.d.ts\",\n        \"enums.d.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": false,\n    \"targetVersions\": {\n        \"target\": \"5.0.12\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"authors\": [\n        \"Bill Siever <bsiever@gmail.com>\"\n    ]\n}\n","README.md":"# time-and-date\n\n```package\nmicrobit-pxt-timeanddate=github:bsiever/microbit-pxt-timeanddate\n```\n\nThis extension allows the micro:bit to keep track of the time and date.  It can also be used for primitive [stopwatch](#stopwatch-behavior)-like capabilities.\n\nIt's importantant to be aware that:\n- This extension uses a counter with differing accuracy on the v1 and v2 micro:bits:\n  - The v1 stability is about 10 parts per million, which is approximately 0.864 seconds per day and \n  - The v2 stability is 50 parts per million, which is about 4.32 seconds per day.  \n- The accuracy may change based on the environment (heat/cold) and from micro:bit to micro:bit.\n- If accuracy is important, you can use the stopwatch experiment described [below](#measuring-accuracy-and-calibrating) to estimate the accuracy of your micro:bit where you plan to use it.\n- The time needs to be set each time the micro:bit is reprogrammed or restarts.  \n\n# Compatability\n\n- Bluetooth is not currently supported on v1 (it is on v2)\n- Some v2 features, like low power mode or playing a melody continuously, may interfer with time keeping.\n\n\n## Setting the Time #setting-the-time\n\nThere are three common approaches to setting the time:\n\n1. [Synchronize at startup](#1-synchronize-at-startup) (easiest, but requires updating the program)\n2. [Time advancing / rewinding](#2-time-advancing-rewinding)\n3. [Digits count up / count down](#3-digits-count-up-count-down)\n\nUsing a reasonable \"startup value\", as described in [Synchronize at startup](#1-synchronize-at-startup), will make the last two approaches easier.\n\n### 1. Synchronize at startup #1-synchronize-at-startup\n\nSynchronizing the time at startup is the easiest approach, but it requires re-programming the micro:bit every time the time needs to be set, like whenever it is restarted.  The start up process just needs to include setting the time, like:\n\n```block\ntimeanddate.setDate(1, 20, 2022)\ntimeanddate.set24HourTime(13, 30, 0)\n```\n\n### ~hint\n\n#### Date is Optional!\n\nIf you just care about time and not the date, you don't have to set the date.\n\n### ~\n\nOnce you're ready to program the micro:bit:\n1. Update the time/date being used so the time is approximately 1 minute in the future.\n2. Program the micro:bit.\n3. Watch the real time carefully.\n4. About 1-2 seconds before the programmed time, press the reset button on the back of the micro:bit.\n   * The micro:bit takes about 1-2 seconds to restart. This causes the \"set\" block to run at the correct time.\n   \nFor the example above, the micro:bit would be reset at 13:29.58s on Jan. 20, 2022.  It would set the date and time at almost exactly the time indicated in the set block.\n\n### 2. Time advancing / rewinding #2-time-advancing-rewinding\n\nThis is the approach used by mechanical clocks, where time is set by moving the minute hand forward (or, possibly, backwards). Moving the minutes forward may cause the hours to change too. And as hours change the date could change, etc.\n\nThis is  a tedious way to set dates and should probably only be used when the date will never be needed and just the time needs to be set.\n\n#### 2.1 Simplest Approach\n\nHere's the simplest approach, where the buttons are dedicated to setting the time :\n\n```block\ninput.onButtonPressed(Button.A, function () {\n    timeanddate.advanceBy(1, timeanddate.TimeUnit.Minutes)\n})\n\ninput.onButtonPressed(Button.B, function () {\n    timeanddate.advanceBy(-1, timeanddate.TimeUnit.Minutes)\n})\n```\n\nThe buttons change the time one minute at a time (forward or backward).  Advancing the minutes beyond 59 or before 0 will cause the hour to change.\n\n#### 2.2 Alternate Approach: Setting at startup\n\nHere's an alternate approach that can be used to set the time at startup by advancing hours and minutes.  \n1. Hold \"A\" until the correct hour is shown.\n2. Hold \"B\" until the message says \"min:\".\n3. Hold \"A\" until the correct minute is shown.  \n4. Hold \"B\" again.\n\n```blocks\ninput.onButtonPressed(Button.A, function () {\n    basic.showString(timeanddate.time(timeanddate.TimeFormat.HMM))\n})\nbasic.showString(\"hr:\")\nwhile (!(input.buttonIsPressed(Button.B))) {\n    if (input.buttonIsPressed(Button.A)) {\n        timeanddate.advanceBy(1, timeanddate.TimeUnit.Hours)\n    }\n    basic.showString(timeanddate.time(timeanddate.TimeFormat.HMM))\n}\nbasic.showString(\"min:\")\nwhile (!(input.buttonIsPressed(Button.B))) {\n    if (input.buttonIsPressed(Button.A)) {\n        timeanddate.advanceBy(1, timeanddate.TimeUnit.Minutes)\n    }\n    basic.showString(timeanddate.time(timeanddate.TimeFormat.HMM))\n}\n```\n\nIf setting the date this way it's best to use the ``[timeanddate.setDate()]`` to select a year near the current year.\n\n**This may not work correctly when the total time is before the year specified in ``[timeanddate.setDate()]``.   That is, if ``[timeanddate.setDate(1, 20, 2024)]`` specifies 2024, then negative values should not \"rollback\" before Jan 1, 2024.**\n\n### 3. Digits count up / count down #3-digits-count-up-count-down\n\nThis approach should be done on each digits of the time (minutes, hours, and if the date is important too, day, month, and year).  \n\n#### 3.1 Simplest Approach Example\n\nHere's an example that focuses on just the minutes (additional code is needed for hours, etc.):\n\n```block\ninput.onButtonPressed(Button.B, function () {\n    timeanddate.numericTime(function (hour, minute, second,  month, day, year) {\n        timeanddate.set24HourTime(hour, minute + -1, second)\n    })\n})\n\ninput.onButtonPressed(Button.A, function () {\n    timeanddate.numericTime(function (hour, minute, second,  month, day, year) {\n        timeanddate.set24HourTime(hour, minute + 1, second)\n    })\n})\n```\n\nSince the time setting commands use modular arithmetic, adding and subtracting to the prior value will \"rollover\" in the expected way and will not impact the hours, like the advancing approach would.\n\n#### 3.2 Alternate Approach: Setting Hour/Minute at Start\n\nThe following can be used to set the time at startup.  It will scroll the time continuously until you are done setting it.  \n\n1. Set the Hour by holding \"A\" to advance it or \"B\" to decrease it.\n2. Hold \"A+B\" until it says \"Set Min\".\n3. Then repeat the process for the minute.  \n4. When done hold \"A+B\" until the message stops scrolling.  \n\nOnce the time has been set the additional code that displays the time when \"A\" is pressed.\n\n```block\ninput.onButtonPressed(Button.A, function () {\n    basic.showString(timeanddate.time(timeanddate.TimeFormat.HMMAMPM))\n})\ntimeanddate.setTime(11, 30, 0, timeanddate.MornNight.AM)\nbasic.showString(\"Set Hour\")\nwhile (!(input.buttonIsPressed(Button.AB))) {\n    timeanddate.numericTime(function (hour, minute, second, month, day, year) {\n        if (input.buttonIsPressed(Button.A)) {\n            timeanddate.set24HourTime(hour + 1, minute, 0)\n        } else if (input.buttonIsPressed(Button.B)) {\n            timeanddate.set24HourTime(hour - 1, minute, 0)\n        }\n    })\n    basic.showString(timeanddate.time(timeanddate.TimeFormat.HMMAMPM))\n}\nbasic.showString(\"Set Min\")\nwhile (!(input.buttonIsPressed(Button.AB))) {\n    timeanddate.numericTime(function (hour, minute, second, month, day,  year) {\n        if (input.buttonIsPressed(Button.A)) {\n            timeanddate.set24HourTime(hour, minute + 1, 0)\n        } else if (input.buttonIsPressed(Button.B)) {\n            timeanddate.set24HourTime(hour, minute - 1, 0)\n        }\n    })\n    basic.showString(timeanddate.time(timeanddate.TimeFormat.HMMAMPM))\n}\n```\n\n# Full API\n\n## Setting Time Using 24-hour Format #timeanddate-set24hourtime\n\nUse `[timeanddate.set24HourTime()]` to set the time using 24-hour format (hours from 0-23, minutes from 0-59, seconds from 0-59). See [Setting the Time](#setting-the-time).\n\n## Setting Time Using AM/PM Format #timeanddate-settime\n\nUse `[timeanddate.setTime()]` to set the time using am/pm format (hours from 1-12, minutes from 0-59, seconds from 0-59).  See [Setting the Time](#setting-the-time).\n\n## Setting the Date #timeanddate-setdate\n\nUse `[timeanddate.setDate()]` to set the date (month from 1-12, day from 1-31, year from 0000-9999). See [Setting the Time](#setting-the-time).\n\n## Getting the Time (string) #timeanddate-time\n\n```sig\ntimeanddate.time(timeanddate.TimeFormat.HMM)\n```\n\nProvides the current time in the selected format. \n\nIf no time has been set, the time will be based on when the micro:bit started (was reset).  By default time starts at 00:00.00 on 0000-01-01.\n\n\n## Getting the Date (string) #timeanddate-date\n\n```sig\ntimeanddate.date(timeanddate.DateFormat.MD)\n``` \n\nProvides the current date in the specified format. \n\nIf no date is set, it will start at 0000-01-01 when the micro:bit starts. \n\n### ~alert\n\n# Avoid using separate time and date if making a log of events\n\nRetrieving the time and date separately can cause problems.  For example, if the date is accessed at 23:59.59 and then time is then accessed, the time may have changed to 00:00.00 (the following day) and the date won't be correct for the time.\n\nUse the timestamp  or the ``[timeanddate.numericTime()]`` block to get numeric values for the date. \n\n### ~\n\n## Timestamps (string) #timeanddate-datetime\n\nOften a \"timestamp\" is needed to record events, like when measurements are taken for a science experiment.  Use:\n\n```sig \ntimeanddate.dateTime()\n``` \n\nIt provides the date and time in the format: YYYY-MM-DD HH:MM.SS.  This format can easily be \"sorted\" in spreadsheets.  This ensures that the date and time are retrieved at the same time (accessing them separately may lead to a date after the time if the the time is checked at almost exactly the end of\n the day).  See [Setting the Time](#setting-the-time).\n\n### ~hint\n\n#### When to use Timestamps\nUse timestamps when logging events that happen over multiple days  (more than 24 hours).   For example, an experiment recoding temperature every 10 minutes for a week should use timestamps.\n\n### ~\n\n## Accessing numeric values of time / date #timeanddate-numerictime\n \nNumeric values of time/date can be useful for things like alarm clocks.  Use:\n\n```sig\ntimeanddate.numericTime(function (hour, minute, second, month, day, year) {\n})\n```\n\n- Hour will be 0-23 (in 24-hour format)\n- Minute will be 0-59\n- Second will be 0-59.\n- Day will be 1-31\n- Month will be 1-12\n- Year is the year 0-65535\n\n### ~tip\n\n#### Numeric Time vs. separate hour, minute, second\n\nThe ``[timeanddate.numericTime()]``  avoids errors that can occur if separate things had been used to get each part of the time.  For example, if one block provided the current time of day\nand another block provided the date, it would be possible to access the time at 23:59.59 on 2020-01-01 and then the date a fraction of time later, \nwhen it had changed to 2020-01-02.  The combined date and time would appear to be 23:59.59 on 2020-01-02 even though the 23:59.59 was actually on 2020-01-01.\n\n### ~\n\n## Advancing and Adjusting Time #timeanddate-advanceby \n\n```sig\ntimeanddate.advanceBy(amount: number, unit: TimeUnit)\n``` \n\nCan be used to advance or set back the current time. It works by adding time to the current time in the given units, *with carries*.  Adding \nto minutes may cause an overflow and change the hours.  Negative amounts can be used to set the clock backwards, however the clock \ncan not be set back before the beginning of the year originally used to set the date (or year 0 if the date wasn't set).\n\nIt behaves like a mechanical clock: Advancing the minutes causes the hour to advance as well.  It may be useful \nfor adjusting the clocks accuracy (adding seconds occasionally if it's slow) or adjusting \nfor changes in timezone or daylight savings time.\n\n## Seconds the Micro:bit has been running #timeanddate-secondssincereset\n\n```sig\ntimeanddate.secondsSinceReset()\n```\n\nReports the time (in seconds) since the micro:bit started.\n\n## Minute Changing #timeanddate-onminutechanged\n\n```sig \ntimeanddate.onMinuteChanged(handler: () => void)\n```\nThe provided code will run when the minute changes. \n\n\n## Hour Changing #timeanddate-onhourchanged\n\n```sig\ntimeanddate.onHourChanged(handler: () => void)\n```\n\nThe provided code will run when the hour changes. \n\n\n## Day Changing #timeanddate-ondaychanged\n\n```sig\ntimeanddate.onDayChanged(handler: () => void)\n```\n\nThe provided code will run when the day changes. \n\n\n## Weekdays #timeanddate-datetodayofweek\n\nOnce you have the day, month, and year, you can use them on the:\n```sig\ntimeanddate.dateToDayOfWeek()\n```\n\nto determine the day of the week.  It returns a numeric code, where 0 is Monday, 1 is Tuesday, etc.\n\n## Day of the Year #timeanddate-datetodayofyear\n\nOnce you have the day, month, and year, you can use them on the:\n```sig\ntimeanddate.dateToDayOfYear()\n```\nto determine the ordinal day of the year.  1 is Jan. 1, 2, is Jan 2, etc.  Dec. 31 is either 365 or 366 (in a leap year).\n\n\n# Measuring Accuracy and Calibrating #measuring-accuracy-and-calibrating\n\nAccuracy can be estimated by comparing your micro:bit to an actual, accurate stopwatch.  \n\nUse the following program, which will start the time at 00:00.00 (just like a stop watch). \n\n```block\ninput.onButtonPressed(Button.A, function () {\n    basic.showString(timeanddate.dateTime())\n})\ninput.onButtonPressed(Button.B, function () {\n    basic.clearScreen()\n})\nbasic.showIcon(IconNames.Heart)\ntimeanddate.set24HourTime(0, 0, 0)\n```\n\nUse a stopwatch or stopwatch app on a computer/phone. To start measurement:\n1. To estimate the accuracy of the micro:bit you'll need to compare it's estimate of time to the stopwatch for a few hours (or even days). Be sure that it's set up someplace where it will have power continuously, either via battery or a USB cable,  for a long time (hours or days). Some computers will suspend power to USB devices if the computer isn't in use for a while, so you may want to use a USB  charger.\n   * The micro:bit's accuracy can be impacted by large changes in temperature.  It's best to test it in an environment that you'll be using it in.  That is, if it'll be left outside in cold weather, test the accuracy in similar conditions. \n2. Prepare to start the stopwatch\n3. Reset the micro:bit\n4. As soon as you see the heart on the micro:bit start the stopwatch \n\nThe micro:bit should be accurate to within about 1 second per day or better.  This experiment depends on your reaction time, which is probably about 0-2 seconds.  Consequently you may need to let it run for several days to estimate the accuracy. \n\nTo estimate the accuracy:\n1. Look at the stopwatch.  Pick a precise instant that you'll take the measurement and keep it in mind.  For example, if the  stop watch reads 2:13.20 you may decide to make the measurement at 2:14.00.\n2. At that precise instant press the \"A\" button.  The micro:bit will scroll it's current record of the time.  Compare it to the expected time.  For example, if the microbit indicated 0000-01-01 02:13.22 you'd estimate that the microbit  is about 2 seconds ahead. Since it's been running for 134 minutes, you'd estimate that it's gaining 2/134 seconds/minute. Since there are 1440 minutes in a day, this works out to about 21.5 seconds per day.\n\n### ~tip\n\n#### Improving Accuracy\nIf you measure the accuracy and it's consistent/predictable, you may be able to use the ``[timeanddate.advanceBy()]`` and ``[timeanddate.onHourChanged()]`` blocks to periodically adjust the accuracy.  \n \n**Be careful setting time backward while using ``[timeanddate.onHourChanged()]``!** It's possible to get stuck in a \"loop\" that continually resets the time. You may need to use a variable to identify which \"hour\" was the last one to be adjusted. \n\n### ~\n\n# Stopwatch behavior #stopwatch-behavior\n\nBy use of setting time to 0:0.0 this can be used as a simple stopwatch.  For example, for timing things that are less than 24 hours:\n\n```block\ninput.onButtonPressed(Button.A, function () {\n    timeanddate.set24HourTime(0, 0, 0)\n})\ninput.onButtonPressed(Button.B, function () {\n    basic.showString(timeanddate.time(timeanddate.TimeFormat.HHMMSS24hr))\n})\ntimeanddate.set24HourTime(0, 0, 0)\n```\n\n\"A\" starts counting and \"B\" shows the time elapsed since \"A\" was pressed (or the start)\n\n\n# Challenges!!!\n\n1. Find new ways to set the time or date.  \n2. Create an alarm clock! (Hint: Use ``[timeanddate.numericTime()]``)\n   * Start with a simple alarm that is pre-programmed. For example, the alarm will go off at 3pm each day.  The ``[timeanddate.numericTime()]`` uses 24-hour format time, so 3pm is 15:00. \n3. Add a snooze feature to your alarm clock!\n4. Create an adjustable alarm clork that allows the alarm time to be changed by using buttons or actions (rather than reprogramming) \n3. Create a clock *without*  these blocks!  Hints: You'll need a few counter variables, a forever loop, and the ability to ``[basic.pause()]``.\n\n\n# Bonus: A Binary Clock \n\nHere's a simple clock that will show time in binary code.  Each column represents a digit of the current 12-hour time. \nThe bottom most LED in each column is the 1's digit, the second from the bottom is the 2's, etc.  The middle column of the display will blink a pattern off and on to indicate each second.\n\n[Click here to open the shared project](https://makecode.microbit.org/_MJqeqei2aFjJ)\n\n```block\nfunction binaryDisplayOf (num: number, col: number) {\n    for (let index = 0; index <= 4; index++) {\n        if (Math.idiv(num, 2 ** index) % 2 == 1) {\n            led.plot(col, 4 - index)\n        } else {\n            led.unplot(col, 4 - index)\n        }\n    }\n}\ninput.onButtonPressed(Button.B, function () {\n    timeanddate.advanceBy(1, timeanddate.TimeUnit.Minutes)\n})\ninput.onButtonPressed(Button.A, function () {\n    basic.showString(timeanddate.time(timeanddate.TimeFormat.HMM))\n})\ninput.onButtonPressed(Button.AB, function () {\n    timeanddate.advanceBy(15, timeanddate.TimeUnit.Minutes)\n})\nbasic.showString(\"hr:\")\nwhile (!(input.buttonIsPressed(Button.B))) {\n    if (input.buttonIsPressed(Button.A)) {\n        timeanddate.advanceBy(1, timeanddate.TimeUnit.Hours)\n    }\n    basic.showString(timeanddate.time(timeanddate.TimeFormat.HMM))\n}\nbasic.showString(\"min:\")\nwhile (!(input.buttonIsPressed(Button.B))) {\n    if (input.buttonIsPressed(Button.A)) {\n        timeanddate.advanceBy(1, timeanddate.TimeUnit.Minutes)\n    }\n    basic.showString(timeanddate.time(timeanddate.TimeFormat.HMM))\n}\nlet blink = false\nbasic.forever(function () {\n    timeanddate.numericTime(function (hour, minute, second, month, day, year) {\n        hour = 0 % 12\n        if (hour == 0) {\n            hour = 12\n        }\n        binaryDisplayOf(Math.idiv(hour, 10), 0)\n        binaryDisplayOf(hour % 10, 1)\n        binaryDisplayOf(Math.idiv(minute, 10), 3)\n        binaryDisplayOf(minute % 10, 4)\n    })\n    basic.pause(1000)\n    blink = !(blink)\n    if (blink) {\n        binaryDisplayOf(10, 2)\n    } else {\n        binaryDisplayOf(0, 2)\n    }\n})\n```\n\n# Bonus: A Stopwatch\n\nHere's a simple stopwatch.  \"A\" starts and stops the count. The count will be automatically displayed\nwhen it's stopped, but pressing \"B\" will re-display it.\n\n[Click here to open the shared project](https://makecode.microbit.org/_2MK536dctd0m)\n\n```block\ninput.onButtonPressed(Button.A, function () {\n    running = !(running)\n    if (running) {\n        timeanddate.set24HourTime(0, 0, 0)\n    } else {\n        captured = timeanddate.time(timeanddate.TimeFormat.HHMMSS24hr)\n        basic.showString(captured)\n    }\n})\ninput.onButtonPressed(Button.B, function () {\n    if (!(running)) {\n        basic.showString(captured)\n    }\n})\nlet dotLocation = 0\nlet xy = 0\nlet captured = \"\"\nlet running = false\nrunning = false\nlet coords = [11, 21, 31, 32, 33, 23, 13, 12]\nbasic.forever(function () {\n    if (running) {\n        basic.clearScreen()\n        xy = coords[dotLocation]\n        led.toggle(Math.idiv(xy, 10), xy % 10)\n        basic.pause(1000/8)\n        dotLocation = (dotLocation + 1) % 8\n    } else {\n        basic.showIcon(IconNames.No)\n    }\n})\n```\n\n## Misc Links & References\n\n- Algorithms used here and Unit tests for them are available on GitHub: https://github.com/bsiever/software-based-RTC-algorithm\n- SparkFun's Guide was used to help develop this package: https://learn.sparkfun.com/tutorials/how-to-create-a-makecode-package-for-microbit/all\n- I develop micro:bit extensions in my spare time to support activities I'm enthusiastic about, like summer camps and science curricula.  You are welcome to become a sponsor of my micro:bit work (one time or recurring payments), which helps offset equipment costs: [here](https://github.com/sponsors/bsiever). Any support at all is greatly appreciated!\n\n## Supported targets\n\n* for PXT/microbit\n\n\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script>\n<script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>","timeanddate.ts":"/**\n * Provides a software based running clock for the time and date for the micro:bit. \n * The micro:bit doesn't have a true real-time clock. The microbit uses a timer derived from the\n * 16MHz clock, which is crystal based and should have an accuracy near 10 part per million, \n * or about 0.864 seconds/day.\n *\n * @author Bill Siever\n */\n//% block=\" Time and Date\"\n//% color=\"#AA278D\"  icon=\"\\uf017\"\nnamespace timeanddate {\n    /* \n        This ensures that \"time\" is checked periodically and event handlers are called.  \n    */\n    loops.everyInterval(2000, function () {\n        // Only run about every 2 s;  Micro:bit uses a ticker with a 32kHz period, so the count should increase by about 65kHz\n        const cpuTime = cpuTimeInSeconds()\n        const t = timeFor(cpuTime)\n        if (lastUpdateMinute != t.minute) {\n            // New minute\n            control.raiseEvent(TIME_AND_DATE_EVENT, TIME_AND_DATE_NEWMINUTE)\n            lastUpdateMinute = t.minute\n        }\n        if (lastUpdateHour != t.hour) {\n            // New hour\n            control.raiseEvent(TIME_AND_DATE_EVENT, TIME_AND_DATE_NEWHOUR)\n            lastUpdateHour = t.hour\n        }\n        if (lastUpdateDay != t.day) {\n            // New day\n            control.raiseEvent(TIME_AND_DATE_EVENT, TIME_AND_DATE_NEWDAY)\n            lastUpdateDay = t.day\n        }\n    })\n\n\n    // ********* Enumerations for parameter types ************************\n\n    export enum MornNight {\n        //% block=\"am\"\n        AM,\n        //% block=\"pm\"\n        PM\n    }\n\n    export enum TimeUnit {\n        //% block=\"ms\"\n        Milliseconds,\n        //% block=\"seconds\"\n        Seconds,\n        //% block=\"minutes\"\n        Minutes,\n        //% block=\"hours\"\n        Hours,\n        //% block=\"days\"\n        Days\n    }\n\n    export enum TimeFormat {\n        //% block=\"as h:mm.ss am / pm\"\n        HMMSSAMPM,\n        //% block=\"as hh:mm 24-hr\"\n        HHMM24hr,\n        //% block=\"as hh:mm.ss 24-hr\"\n        HHMMSS24hr,\n        //% block=\"as h:mm\"\n        HMM,\n        //% block=\"as h:mm am / pm\"\n        HMMAMPM,\n    }\n\n    export enum DateFormat {\n        //% block=\"as month/day\"\n        MD,\n        //% block=\"as month/day/year\"\n        MDY,\n        //% block=\"as year-month-day\"\n        YYYY_MM_DD\n    }\n\n    type Month = uint8   // 1-12 Month of year\n    type Day = uint8     // 1-31 / Day of month\n    type Year = uint16 // Assumed to be 0000-0099 or 2020-2099  \n    type Hour = uint8  // 0-23 / 24-hour format  \n    type Minute = uint8 // 0-59 \n    type Second = uint8 // 0-59\n    type DayOfYear = uint16 // 1-366\n\n    type SecondsCount = uint32 // Seconds since start of start year\n    type Weekday = uint8 // Weekday code. 0=Sunday, 1=Monday, etc.\n\n    interface DateTime {\n        month: Month   // 1-12 Month of year\n        day: Day   // 1-31 / Day of month\n        year: Year  // Assumed to be 2020 or later\n        hour: Hour   // 0-23 / 24-hour format  \n        minute: Minute   // 0-59 \n        second: Second   // 0-59\n        dayOfYear: DayOfYear  // 1-366\n    }\n\n    interface MonthDay {\n        month: Month   // 1-12 Month of year\n        day: Day   // 1-31 / Day of month\n    }\n\n    // ********* State Variables ************************\n\n    const TIME_AND_DATE_EVENT = 94\n    const TIME_AND_DATE_NEWMINUTE = 1\n    const TIME_AND_DATE_NEWHOUR = 2\n    const TIME_AND_DATE_NEWDAY = 3\n\n    // State variables to manage time \n    let startYear: Year = 0\n    let timeToSetpoint: SecondsCount = 0\n    let cpuTimeAtSetpoint: SecondsCount = 0\n\n    /*    \n    Time is all relative to the \"start year\" that is set by setDate() (or 0 by default) as follows:\n\n      Start year          Time Date/Time set        CurrentCPUTime\n      |                   | (in s)                  | (in s)\n      V                   V                         V\n      |-------------------+-------------------------|\n                          ^\n                          |\n                          Known dd/mm/yy hh:mm,.s\n                          AND cpuTimeAtSetpoint (in s)\n       |------------------|-------------------------|\n          timeToSetpoint          deltaTime\n          (in s)                  ( in s)\n    \n        setDate sets the startYear and updates timeToSetpoint and cpuTimeAtSetpoint \n        setTime methods update just timeToSetpoint and cpuTimeAtSetpoint\n     */\n\n    // State for event handlers \n    let lastUpdateMinute: Minute = 100   // Set to invalid values for first update\n    let lastUpdateHour: Hour = 100\n    let lastUpdateDay: Day = 100\n\n\n    // Cummulative Days of Year (cdoy): Table of month (1-based indices) to cummulative completed days prior to month\n    // Ex: By Feb 1st (2nd month / index 2), 31 days of Jan are completed. \n    const cdoy: DayOfYear[] = [0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]\n\n    // ********* Time Calculation / Management ************************\n\n\n    function isLeapYear(y: Year): boolean {\n        // The /400 and /100 rules don't come into play until 2400 and 2300 or 0100.  We can ignore them here\n        // Here's the code for accurate handling of leap years:\n        return (y % 400 == 0 || (y % 100 != 0 && y % 4 == 0))\n\n        // Simplified case for 2020-2099.\n        // return y % 4 == 0\n    }\n\n\n    // Returns a MonthDay with from a DayOfYear and given Year\n    function dayOfYearToMonthAndDay(d: DayOfYear, y: Year): MonthDay {\n        // If it's after Feb in a leap year, adjust\n        if (isLeapYear(y)) {\n            if (d == 60) {  // Leap Day!\n                return { month: 2, day: 29 }\n            } else if (d > 60) {\n                d -= 1  // Adjust for leap day\n            }\n        }\n        for (let i = 1; i < cdoy.length; i++) {  // Start at 1 for 1- based index\n            // If the day lands in (not through) this month, return it\n            if (d <= cdoy[i + 1]) {\n                return { month: i, day: d - cdoy[i] }\n\n            }\n        }\n        // This should never happen!\n        return { month: -1, day: -1 }\n    }\n\n    function secondsSoFarForYear(m: Month, d: Day, y: Year, hh: Hour, mm: Minute, ss: Second): SecondsCount {\n        // ((((Complete Days * 24hrs/ day)+complete hours)*60min/ hr)+complete minutes)* 60s/ min + complete seconds\n        // Yay Horner's Rule!:\n        return (((dateToDayOfYear(m, d, y) - 1) * 24 + hh) * 60 + mm) * 60 + ss\n    }\n\n    function timeFor(cpuTime: SecondsCount): DateTime {\n        const deltaTime = cpuTime - cpuTimeAtSetpoint\n        let sSinceStartOfYear = timeToSetpoint + deltaTime\n        // Find elapsed years by counting up from start year and subtracting off complete years\n        let y = startYear\n        let leap = isLeapYear(y)\n        while ((!leap && sSinceStartOfYear > 365 * 24 * 60 * 60) || (sSinceStartOfYear > 366 * 24 * 60 * 60)) {\n            if (leap) {\n                sSinceStartOfYear -= 366 * 24 * 60 * 60\n            } else {\n                sSinceStartOfYear -= 365 * 24 * 60 * 60\n            }\n            y += 1\n            leap = isLeapYear(y)\n        }\n\n        // sSinceStartOfYear and leap are now for \"y\", not \"year\".  Don't use \"year\"! Use \"y\"\n        // Find elapsed days\n        const daysFromStartOfYear = Math.idiv(sSinceStartOfYear, (24 * 60 * 60)) + 1  // +1 offset for 1/1 being day 1\n        const secondsSinceStartOfDay = sSinceStartOfYear % (24 * 60 * 60)\n\n        // Find elapsed hours\n        const hoursFromStartOfDay = Math.idiv(secondsSinceStartOfDay, (60 * 60))\n        const secondsSinceStartOfHour = secondsSinceStartOfDay % (60 * 60)\n\n        // Find elapsed minutes\n        const minutesFromStartOfHour = Math.idiv(secondsSinceStartOfHour, (60))\n        // Find elapsed seconds\n        const secondsSinceStartOfMinute = secondsSinceStartOfHour % (60)\n\n        // Convert days to dd/ mm\n        const ddmm = dayOfYearToMonthAndDay(daysFromStartOfYear, y) // current year, y, not start year\n        return { month: ddmm.month, day: ddmm.day, year: y, hour: hoursFromStartOfDay, minute: minutesFromStartOfHour, second: secondsSinceStartOfMinute, dayOfYear: daysFromStartOfYear }\n    }\n\n    //% shim=timeanddate::cpuTimeInSeconds\n    function cpuTimeInSeconds(): uint32 {\n        return Math.idiv(input.runningTime(), 1000)\n    }\n\n    // ********* Misc. Utility Functions for formatting ************************\n    function leftZeroPadTo(inp: number, digits: number) {\n        let value = inp + \"\"\n        while (value.length < digits) {\n            value = \"0\" + value\n        }\n        return value\n    }\n\n\n    // 24-hour time:  hh:mm.ss\n    function fullTime(t: DateTime): string {\n        return leftZeroPadTo(t.hour, 2) + \":\" + leftZeroPadTo(t.minute, 2) + \".\" + leftZeroPadTo(t.second, 2)\n    }\n\n    // Full year: yyyy-mm-dd\n    function fullYear(t: DateTime): string {\n        return leftZeroPadTo(t.year, 4) + \"-\" + leftZeroPadTo(t.month, 2) + \"-\" + leftZeroPadTo(t.day, 2)\n    }\n\n\n    // ********* Exposed blocks ************************\n\n\n    /**\n     * Set the time using 24-hour format. \n     * @param hour the hour (0-23)\n     * @param minute the minute (0-59)\n     * @param second the second (0-59)\n     */\n    //% block=\"set time from 24-hour time |  $hour | : $minute | . $second\"\n    //% hour.min=0 hour.max=23 hour.defl=13\n    //% minute.min=0 minute.max=59 minute.defl=30\n    //% second.min=0 second.max=59 second.defl=0\n    //% weight=90\n    export function set24HourTime(hour: Hour, minute: Minute, second: Second) {\n        hour = hour % 24\n        minute = minute % 60\n        second = second % 60\n        const cpuTime = cpuTimeInSeconds()\n        const t = timeFor(cpuTime)\n        cpuTimeAtSetpoint = cpuTime\n        timeToSetpoint = secondsSoFarForYear(t.month, t.day, t.year, hour, minute, second)\n    }\n\n    /**\n     * Set the date\n     * @param month the month 1-12\n     * @param day the day of the month 1-31\n     * @param the year 2020-2050\n     */\n    //% block=\"set date to | month $month | / day $day | / year $year\"\n    //% month.min=1 month.max=12 month.defl=1\n    //% day.min=1 day.max=31 day.defl=20\n    //% year.min=2020 year.max=2050 year.defl=2022\n    //% weight=80\n    export function setDate(month: Month, day: Day, year: Year) {\n        month = month % 13\n        day = day % 32\n        const cpuTime = cpuTimeInSeconds()\n        const t = timeFor(cpuTime)\n        startYear = year\n        cpuTimeAtSetpoint = cpuTime\n        timeToSetpoint = secondsSoFarForYear(month, day, startYear, t.hour, t.minute, t.second)\n    }\n\n    /**\n     * Set the time using am/pm format\n     * @param hour the hour (1-12)\n     * @param minute the minute (0-59)\n     * @param second the second (0-59)\n     * @param ampm morning or night\n     */\n    //% block=\"set time to |  $hour | : $minute | . $second | $ampm\"\n    //% hour.min=1 hour.max=12 hour.defl=11\n    //% minute.min=0 minute.max=59 minute.defl=30\n    //% second.min=0 second.max=59 second.defl=0\n    //% inlineInputMode=inline\n    //% weight=100\n    export function setTime(hour: Hour, minute: Minute, second: Second, ampm: MornNight) {\n        hour = hour % 13\n        // Adjust to 24-hour time format\n        if (ampm == MornNight.AM && hour == 12) {  // 12am -> 0 hundred hours\n            hour = 0;\n        } else if (ampm == MornNight.PM && hour != 12) {   // PMs other than 12 get shifted after 12:00 hours\n            hour = hour + 12;\n        }\n        set24HourTime(hour, minute, second);\n    }\n\n    /**\n     * Advance the time by the given amount, which cause \"carries\" into other aspects of time/date.  Negative values will cause time to go back by the amount.\n     * @param amount the amount of time to add (or subtract if negative).  To avoid \"carries\" use withTime blocks\n     * @param unit the unit of time\n     */\n    //% block=\"advance time/date by | $amount | $unit \" advanced=true\n    //% weight=50\n    export function advanceBy(amount: number, unit: TimeUnit) {\n        const units = [0, 1, 60 * 1, 60 * 60 * 1, 24 * 60 * 60 * 1]\n        // Don't let time go negative:\n        if (amount < 0 && (-amount * units[unit]) > timeToSetpoint)\n            timeToSetpoint = 0\n        else\n            timeToSetpoint += amount * units[unit]\n    }\n\n\n    /**\n     * Get the Day of the week  \n     *  0=>Monday, 1=>Tuesday, etc.\n     */\n    //% block=\"day of week for month $month / day $day / year $year\" advanced=true\n    //% month.min=1 month.max=12 month.defl=1\n    //% day.min=1 day.max=31 day.defl=20\n    //% year.min=2020 year.max=2050 year.defl=2022\n    //% weight=40\n    export function dateToDayOfWeek(month: Month, day: Day, year: Year): Weekday {\n        let doy = dateToDayOfYear(month, day, year)\n        // Gauss's Algorithm for Jan 1: https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week\n        // R(1+5R(A-1,4)+4R(A-1,100)+6R(A-1,400),7)    \n        let jan1 = ((1 + 5 * ((year - 1) % 4) + 4 * ((year - 1) % 100) + 6 * ((year - 1) % 400)) % 7)\n        jan1 += 6  // Shift range:  Gauss used 0=Sunday, we'll use 0=Monday\n        return ((doy - 1) + jan1) % 7\n    }\n\n    /**\n     * Get the Day of the year  \n     *  Jan 1 = 1, Jan 2=2, Dec 31 is 365 or 366\n     */\n    //% block=\"day of year for month $month / day $day / year $year\" advanced=true\n    //% month.min=1 month.max=12 month.defl=1\n    //% day.min=1 day.max=31 day.defl=20\n    //% year.min=2020 year.max=2050 year.defl=2022\n    //% weight=30\n    export function dateToDayOfYear(month: Month, day: Day, year: Year): DayOfYear {\n        month = Math.constrain(month, 1, 12)\n        // Assumes a valid date\n        let dayOfYear = cdoy[month] + day\n        // Handle after Feb in leap years:\n        if (month > 2 && isLeapYear(year)) {\n            dayOfYear += 1\n        }\n        return dayOfYear\n    }\n\n    /**\n     * Get all values of time as numbers.  \n     */\n    //% block=\"time as numbers $hour:$minute.$second on $month/$day/$year\" advanced=true\n    //% draggableParameters=variable\n    //% handlerStatement=1\n    //% weight=100\n    export function numericTime(handler: (hour: Hour, minute: Minute, second: Second, month: Month, day: Day, year: Year) => void) {\n        const cpuTime = cpuTimeInSeconds()\n        const t = timeFor(cpuTime)\n        handler(t.hour, t.minute, t.second, t.month, t.day, t.year)\n    }\n\n    /**\n     * Current time as a string in the format\n     * @param format the format to use\n     */\n    //% block=\"time as $format\"\n    //% weight=70\n    export function time(format: TimeFormat): string {\n        const cpuTime = cpuTimeInSeconds()\n        const t = timeFor(cpuTime)\n\n        // Handle 24-hour format with helper\n        if (format == TimeFormat.HHMMSS24hr)\n            return fullTime(t)\n\n        // Format minutes for all remaining formats\n        let minute = leftZeroPadTo(t.minute, 2)\n\n        // Simpler military format\n        if (format == TimeFormat.HHMM24hr)\n            return leftZeroPadTo(t.hour, 2) + \":\" + minute\n\n        // Data for all other formats\n        // Compute strings for other formats\n        let hour = null\n        let ap = t.hour < 12 ? \"am\" : \"pm\"\n        if (t.hour == 0) {\n            hour = \"12:\"  // am\n        } else if (t.hour > 12) {\n            hour = (t.hour - 12) + \":\"\n        } else {\n            hour = (t.hour) + \":\"\n        }\n\n        // Compose them appropriately\n        switch (format) {\n            case TimeFormat.HMMSSAMPM:\n                return hour + minute + \".\" + leftZeroPadTo(t.second, 2) + ap\n\n            case TimeFormat.HMMAMPM:\n                return hour + minute + ap\n\n            case TimeFormat.HMM:\n                return hour + minute\n        }\n        return \"\"\n    }\n\n    /**\n     * Current date as a string in the format\n     * @param format the format to use\n     */\n    //% block=\"date as $format\"\n    //% weight=60\n    export function date(format: DateFormat): string {\n        const cpuTime = cpuTimeInSeconds()\n        const t = timeFor(cpuTime)\n        switch (format) {\n            case DateFormat.MD:\n                return t.month + \"/\" + t.day\n                break\n            case DateFormat.MDY:\n                return t.month + \"/\" + t.day + \"/\" + t.year\n                break\n            case DateFormat.YYYY_MM_DD:\n                return fullYear(t)\n                break\n        }\n        return \"\"\n    }\n\n    /**\n     * Current date and time in a timestamp format (YYYY-MM-DD HH:MM.SS).  \n     */\n    //% block=\"date and time stamp\"\n    //% weight=50\n    export function dateTime(): string {\n        const cpuTime = cpuTimeInSeconds()\n        const t = timeFor(cpuTime)\n        return fullYear(t) + \" \" + fullTime(t)\n    }\n\n    /**\n     * Seconds since start of micro:bit  \n     */\n    //% block=\"seconds since microbit start\" advanced=true\n    //% weight=40\n    export function secondsSinceReset(): number {\n        return cpuTimeInSeconds()\n    }\n\n\n    /**\n     * Called when minutes change\n     */\n    //% block=\"minute changed\" advanced=true\n    //% weight=85\n    export function onMinuteChanged(handler: () => void) {\n        control.onEvent(TIME_AND_DATE_EVENT, TIME_AND_DATE_NEWMINUTE, handler)\n    }\n\n    /**\n     * Called when hours change\n     */\n    //% block=\"hour changed\" advanced=true\n    //% weight=80\n    export function onHourChanged(handler: () => void) {\n        control.onEvent(TIME_AND_DATE_EVENT, TIME_AND_DATE_NEWHOUR, handler)\n    }\n\n    /**\n     * Called when days change\n     */\n    //% block=\"day changed\" advanced=true\n    //% weight=75\n    export function onDayChanged(handler: () => void) {\n        control.onEvent(TIME_AND_DATE_EVENT, TIME_AND_DATE_NEWDAY, handler)\n    }\n\n    // ***************** This was just for debugging / evaluate problems in API\n    // Helpful for debugging / testing\n    // /**\n    //  * Seconds since start of year  \n    //  */\n    // //% block=\"seconds since year\" advanced=true\n    // export function secondsSinceYear(): number {\n    //     const cpuTime = cpuTimeInSeconds()\n    //     const t = timeFor(cpuTime)\n    //     const deltaTime = cpuTime - cpuTimeAtSetpoint\n    //     let sSinceStartOfYear = timeToSetpoint + deltaTime\n    //     return sSinceStartOfYear\n    // }\n\n    // ********************************************************\n}","timeanddate.cpp":"/**\n * Bill Siever\n * \n * This code is released under the [MIT License](http://opensource.org/licenses/MIT).\n * Please review the LICENSE file.\n */\n\n// Enable debugging or not:  (comment out / #ifdefs)\n//#define DEBUG 1\n\n#include \"pxt.h\"\n#include \"nrf.h\"\n\n#ifdef SOFTDEVICE_PRESENT\n#include \"nrf_nvic.h\"\n// #warning \"****SOFTDEVICE PRESENT****\"\n#else\n// #warning \"******NO SOFTDEVICE PRESENT******\"\n#endif\n\n#if MICROBIT_CODAL\n\n\n#else\n\n//From: https://github.com/ARMmbed/nrf51-sdk/blob/master/source/nordic_sdk/components/drivers_nrf/delay/nrf_delay.h\nstatic void __INLINE nrf_delay_us(uint32_t volatile number_of_us) __attribute__((always_inline));\nstatic void __INLINE nrf_delay_us(uint32_t volatile number_of_us)\n{\nregister uint32_t delay __ASM (\"r0\") = number_of_us;\n__ASM volatile (\n    \".syntax unified\\n\"\n    \"1:\\n\"\n    \" SUBS %0, %0, #1\\n\"\n    \" NOP\\n\"\n    \" NOP\\n\"\n    \" NOP\\n\"\n    \" NOP\\n\"\n    \" NOP\\n\"\n    \" NOP\\n\"   \n    \" NOP\\n\"  \n    \" NOP\\n\"\n    \" NOP\\n\"\n    \" NOP\\n\"\n    \" NOP\\n\"\n    \" NOP\\n\"\n    \" BNE 1b\\n\"\n    \".syntax divided\\n\"\n    : \"+r\" (delay));\n}\n#endif \n\nnamespace timeanddate\n{\n    /* \n       Return the current system CPU time in s \n       Must be called 2x+ every 2^32/1000000 s (~=<15min) or more frequently to \n       ensure proper time keeping \n    */\n    //%\n    uint32_t cpuTimeInSeconds() {\n        static uint64_t totalUs = 0;\n        static uint32_t lastUs = 0;\n        uint32_t currentUs;\n\n#ifdef DEBUG\n        uint32_t retries = 0;\n        static uint32_t lastLastUs = 0;\n#endif\n\n\n#if MICROBIT_CODAL\n        static NRF_TIMER_Type *timer = NULL;\n#ifdef SOFTDEVICE_PRESENT\n         sd_nvic_DisableIRQ(TIMER1_IRQn); \n#else\n        NVIC_DisableIRQ(TIMER1_IRQn);\n#endif\n        // If we haven't gotten the timer yet, do startup tasks, including getting the timer.\n        if(timer == NULL) {\n\n#ifdef SOFTDEVICE_PRESENT\n        if(ble_running() == true) {\n                sd_clock_hfclk_request();\n        } else  {\n                // Ensure the HFCLOCK is running\n                NRF_CLOCK_Type *clock = NRF_CLOCK;\n                clock->TASKS_HFCLKSTART = 1;\n        }\n#else\n        // Ensure the HFCLOCK is running\n        NRF_CLOCK_Type *clock = NRF_CLOCK;\n        clock->TASKS_HFCLKSTART = 1;\n#endif\n            // Get the timer (ensures this is only done once)\n            timer = NRF_TIMER1;\n            // Disable timer\n            timer->TASKS_STOP = 1;\n            // Set bit mode\n            timer->BITMODE = 3;\n            // Restart it\n            timer->TASKS_START = 1;\n        }\n        // Capture the current timer value\n        timer->TASKS_CAPTURE[3] = 1;\n        currentUs = timer->CC[3];\n#ifdef SOFTDEVICE_PRESENT\n        sd_nvic_EnableIRQ(TIMER1_IRQn);\n#else\n        NVIC_EnableIRQ(TIMER1_IRQn);\n#endif\n        // Update the time\n        totalUs += (currentUs - lastUs);\n        lastUs = currentUs;\n\n#ifdef DEBUG \n        uBit.serial.send(\"\\ncurrentUs=\");\n        uBit.serial.send((int)currentUs);\n#endif\n\n#else\n        // Continue to get ticker values until they are valid\n        while(true) {\n            // Try a read \n            currentUs = us_ticker_read();\n            // If it was near the end of the phase, read again \n            // (avoid non-atomic access / race condition error)\n            while((currentUs & 0x0000FFFF) > 0x0000FFC0) {  \n                // Ensure timer before last 64uS of cycle (uS ticker should be about 5uS? Check!)\n                nrf_delay_us(100);\n                currentUs = us_ticker_read();\n            }\n            uint32_t newUs = currentUs - lastUs;\n\n            // Sanity check: only proceed if it's NOT negative  \n            if(!(newUs & 0x80000000)) {\n                // Only add if it's positive (time increased) / valid NOT if the high bit is set)...\n                totalUs += newUs;\n#ifdef DEBUG    \n                lastLastUs = lastUs;\n#endif\n                lastUs = currentUs;\n                break;  // Leave the loop on valid update\n            }\n            else {\n                // The read isn't valid.  Try again soon.\n                fiber_sleep(0);\n#ifdef DEBUG\n                retries++;\n                // Additional debugging info:\n                uBit.serial.send(\"\\nError\");\n                uBit.serial.send(\"\\nlastLastUs=\");\n                uBit.serial.send((int)lastLastUs);\n                uBit.serial.send(\"\\nlastUs=\");\n                uBit.serial.send((int)lastUs);\n                uBit.serial.send(\"\\ncurrentUs=\");\n                uBit.serial.send((int)currentUs);\n                uBit.serial.send(\"\\n\");\n#endif\n            }\n        }\n#ifdef DEBUG\n        if(retries!=0) {\n            uBit.serial.send(\"Retries=\");\n            uBit.serial.send((int)retries);\n            uBit.serial.send(\"\\nFinal\\nlastUs=\");\n            uBit.serial.send((int)lastUs);\n            uBit.serial.send(\"\\ncurrentUs=\");\n            uBit.serial.send((int)currentUs);\n            uBit.serial.send(\"\\nlastLastUs=\");\n            uBit.serial.send((int)lastLastUs);\n            uBit.serial.send(\"\\n\");\n        }\n#endif\n\n#endif\n        return totalUs / 1000000;\n    }\n} // namespace timeanddate\n\n/*\n\nHere's the us_ticker_read():\nhttps://github.com/lancaster-university/mbed-classic/blob/427f56863c9f9a9132a213ec583469dfc61c6244/targets/hal/TARGET_NORDIC/TARGET_MCU_NRF51822/us_ticker.c\n\nReturns: \n  TMR1_UNITS_TO_MICROSECONDS(tmr1_getCounter64());\n  Which expands to:\n    tmr1_getCounter64()  (Yeah, that's dumb / unnesc)\n\nAnd tmr1_getCounter64() is an inline that returns:\n    return (((uint64_t)(overflowCount)) << 16) | (NRF_TIMER1->CC[2] & MAX_TMR1_COUNTER_VAL);\n\nNOTE THE 16-bit BOUNDARY!!!! \n\nThis is a non-atomic read problem.   Just reject reads if NRF_TIMER1->CC[2] & MAX_TMR1_COUNTER_VAL is close to the\nboundary (and of the phase / wrap around).  \n*/","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n    /**\n     * Bill Siever\n     * \n     * This code is released under the [MIT License](http://opensource.org/licenses/MIT).\n     * Please review the LICENSE file.\n     */\n\ndeclare namespace timeanddate {\n}\n\n// Auto-generated. Do not edit. Really.\n","enums.d.ts":"// Auto-generated. Do not edit.\ndeclare namespace timeanddate {\n}\n\n// Auto-generated. Do not edit. Really.\n","test.ts":"\n\n// Run the Test Suite or not?\nconst runTests = true\n\nif (runTests) {\n    //  State variables and utility functions\n    let days = 0\n    let hours = 0\n    let minutes = 0\n\n    function clearCounters() {\n        days = 0\n        hours = 0\n        minutes = 0\n    }\n\n    let errors = 0\n    let testsRun = 0\n    function assert(where: string, expected: any, actual: any) {\n        if(expected==actual) {\n        serial.writeLine(where + \" : Passed\")\n        testsRun += 1\n        } else {\n        errors += 1\n        serial.writeLine(where + \" : FAILED\\t Expected: \" + expected + ' got: ' + actual)\n        }\n    }\n\n    function testingDone() {\n        if(errors==0) {\n            serial.writeLine(\"All \" + testsRun + \" tests passed\")\n            basic.showIcon(IconNames.Happy)\n        } else {\n            serial.writeLine(\"Failed \" + errors + \" of \" + testsRun)\n            while (true) {\n                basic.showIcon(IconNames.Sad)\n                basic.showNumber(errors)\n                break\n            }\n        }\n    }\n\n\n    // Setup tests for callbacks (to modify state variables)\n    timeanddate.onMinuteChanged(function () {\n        minutes += 1\n    })\n    timeanddate.onDayChanged(function () {\n        days += 1\n    })\n    timeanddate.onHourChanged(function () {\n        hours += 1\n    })\n\n\n    // **************** Begin testing ************//\n    basic.pause(1100)\n    // Time should now be at 1s\n    assert(\"TSR\", 1, timeanddate.secondsSinceReset())\n\n\n    // ************* Testing Timestamp, time, and date formats\n\n\n    // Test 1:  Set time to 11:30am on Jan 20, 2020\n    // Also tests set AM to an AM time\n    timeanddate.setTime(11, 30, 0, timeanddate.MornNight.AM)\n    timeanddate.setDate(1, 20, 2020)\n\n    assert(\"dT1\", \"2020-01-20 11:30.00\", timeanddate.dateTime())\n    assert(\"date1a\", \"1/20\", timeanddate.date(timeanddate.DateFormat.MD))\n    assert(\"date1b\", \"1/20/2020\", timeanddate.date(timeanddate.DateFormat.MDY))\n    assert(\"date1c\", \"2020-01-20\", timeanddate.date(timeanddate.DateFormat.YYYY_MM_DD))\n    assert(\"time1a\", \"11:30\", timeanddate.time(timeanddate.TimeFormat.HHMM24hr))\n    assert(\"time1b\", \"11:30.00\", timeanddate.time(timeanddate.TimeFormat.HHMMSS24hr))\n    assert(\"time1c\", \"11:30\", timeanddate.time(timeanddate.TimeFormat.HMM))\n    assert(\"time1d\", \"11:30am\", timeanddate.time(timeanddate.TimeFormat.HMMAMPM))\n    assert(\"time1e\", \"11:30.00am\", timeanddate.time(timeanddate.TimeFormat.HMMSSAMPM))\n\n    // Test 2:  Set time to 12:00pm on Dec 20, 2020\n    // Also tests set AM to 12pm / 1200 hrs and minutes that are <10\n    timeanddate.setTime(12, 0, 0, timeanddate.MornNight.PM)\n    timeanddate.setDate(12, 20, 2020)\n\n    assert(\"dT2\", \"2020-12-20 12:00.00\", timeanddate.dateTime())\n    assert(\"date2a\", \"12/20\", timeanddate.date(timeanddate.DateFormat.MD))\n    assert(\"date2b\", \"12/20/2020\", timeanddate.date(timeanddate.DateFormat.MDY))\n    assert(\"date2c\", \"2020-12-20\", timeanddate.date(timeanddate.DateFormat.YYYY_MM_DD))\n    assert(\"time2a\", \"12:00\", timeanddate.time(timeanddate.TimeFormat.HHMM24hr))\n    assert(\"time2b\", \"12:00.00\", timeanddate.time(timeanddate.TimeFormat.HHMMSS24hr))\n    assert(\"time2c\", \"12:00\", timeanddate.time(timeanddate.TimeFormat.HMM))\n    assert(\"time2d\", \"12:00pm\", timeanddate.time(timeanddate.TimeFormat.HMMAMPM))\n    assert(\"time2e\", \"12:00.00pm\", timeanddate.time(timeanddate.TimeFormat.HMMSSAMPM))\n\n    // Test 3:  Set time to 12:01.02am on June 5, 2020\n    // Also tests set AM to 12am / 00:00 hrs and minutes that are <10\n    //  and seconds that are >0 <10;  Day less than 10\n    timeanddate.setTime(12, 1, 2, timeanddate.MornNight.AM)\n    timeanddate.setDate(6, 5, 2020)\n\n    assert(\"dT3\", \"2020-06-05 00:01.02\", timeanddate.dateTime())\n    assert(\"date3a\", \"6/5\", timeanddate.date(timeanddate.DateFormat.MD))\n    assert(\"date3b\", \"6/5/2020\", timeanddate.date(timeanddate.DateFormat.MDY))\n    assert(\"date3c\", \"2020-06-05\", timeanddate.date(timeanddate.DateFormat.YYYY_MM_DD))\n    assert(\"time3a\", \"00:01\", timeanddate.time(timeanddate.TimeFormat.HHMM24hr))\n    assert(\"time3b\", \"00:01.02\", timeanddate.time(timeanddate.TimeFormat.HHMMSS24hr))\n    assert(\"time3c\", \"12:01\", timeanddate.time(timeanddate.TimeFormat.HMM))\n    assert(\"time3d\", \"12:01am\", timeanddate.time(timeanddate.TimeFormat.HMMAMPM))\n    assert(\"time3e\", \"12:01.02am\", timeanddate.time(timeanddate.TimeFormat.HMMSSAMPM))\n\n\n\n    // Test 1:  Set time to 11:30am on Jan 20, 2020\n    // Also tests set AM to an AM time\n    timeanddate.setTime(11, 30, 0, timeanddate.MornNight.AM)\n    timeanddate.setDate(1, 20, 2020)\n\n    assert(\"dT1\", \"2020-01-20 11:30.00\", timeanddate.dateTime())\n    assert(\"date1a\", \"1/20\", timeanddate.date(timeanddate.DateFormat.MD))\n    assert(\"date1b\", \"1/20/2020\", timeanddate.date(timeanddate.DateFormat.MDY))\n    assert(\"date1c\", \"2020-01-20\", timeanddate.date(timeanddate.DateFormat.YYYY_MM_DD))\n    assert(\"time1a\", \"11:30\", timeanddate.time(timeanddate.TimeFormat.HHMM24hr))\n    assert(\"time1b\", \"11:30.00\", timeanddate.time(timeanddate.TimeFormat.HHMMSS24hr))\n    assert(\"time1c\", \"11:30\", timeanddate.time(timeanddate.TimeFormat.HMM))\n    assert(\"time1d\", \"11:30am\", timeanddate.time(timeanddate.TimeFormat.HMMAMPM))\n    assert(\"time1e\", \"11:30.00am\", timeanddate.time(timeanddate.TimeFormat.HMMSSAMPM))\n\n    // Test 2:  Set time to 12:00pm on Dec 20, 2020\n    // Also tests set AM to 12pm / 1200 hrs and minutes that are <10\n    timeanddate.setTime(12, 0, 0, timeanddate.MornNight.PM)\n    timeanddate.setDate(12, 20, 2020)\n\n    assert(\"dT2\", \"2020-12-20 12:00.00\", timeanddate.dateTime())\n    assert(\"date2a\", \"12/20\", timeanddate.date(timeanddate.DateFormat.MD))\n    assert(\"date2b\", \"12/20/2020\", timeanddate.date(timeanddate.DateFormat.MDY))\n    assert(\"date2c\", \"2020-12-20\", timeanddate.date(timeanddate.DateFormat.YYYY_MM_DD))\n    assert(\"time2a\", \"12:00\", timeanddate.time(timeanddate.TimeFormat.HHMM24hr))\n    assert(\"time2b\", \"12:00.00\", timeanddate.time(timeanddate.TimeFormat.HHMMSS24hr))\n    assert(\"time2c\", \"12:00\", timeanddate.time(timeanddate.TimeFormat.HMM))\n    assert(\"time2d\", \"12:00pm\", timeanddate.time(timeanddate.TimeFormat.HMMAMPM))\n    assert(\"time2e\", \"12:00.00pm\", timeanddate.time(timeanddate.TimeFormat.HMMSSAMPM))\n\n    // Test 4:  Set time to 1:59.59am on April 15, 21\n    timeanddate.setTime(1, 59, 59, timeanddate.MornNight.AM)\n    timeanddate.setDate(4, 15, 21)\n\n    assert(\"dT4\", \"0021-04-15 01:59.59\", timeanddate.dateTime())\n    assert(\"date4a\", \"4/15\", timeanddate.date(timeanddate.DateFormat.MD))\n    assert(\"date4b\", \"4/15/21\", timeanddate.date(timeanddate.DateFormat.MDY))\n    assert(\"date4c\", \"0021-04-15\", timeanddate.date(timeanddate.DateFormat.YYYY_MM_DD))\n    assert(\"time4a\", \"01:59\", timeanddate.time(timeanddate.TimeFormat.HHMM24hr))\n    assert(\"time4b\", \"01:59.59\", timeanddate.time(timeanddate.TimeFormat.HHMMSS24hr))\n    assert(\"time4c\", \"1:59\", timeanddate.time(timeanddate.TimeFormat.HMM))\n    assert(\"time4d\", \"1:59am\", timeanddate.time(timeanddate.TimeFormat.HMMAMPM))\n    assert(\"time4e\", \"1:59.59am\", timeanddate.time(timeanddate.TimeFormat.HMMSSAMPM))\n\n    // Setting time with AM/PM converts to 24HourTime, so it has been tested\n    // timeanddate.set24HourTime(13, 30, 0)\n\n\n    // Test Day Of Week\n    assert(\"dow1\", 0, timeanddate.dateToDayOfWeek(1, 20, 2020))\n    assert(\"dow2\", 1, timeanddate.dateToDayOfWeek(1, 21, 2020))\n    assert(\"dow3\", 5, timeanddate.dateToDayOfWeek(2, 29, 2020))\n    assert(\"dow4\", 6, timeanddate.dateToDayOfWeek(3, 1, 2020))\n    assert(\"dow5\", 0, timeanddate.dateToDayOfWeek(3, 1, 2021))\n    assert(\"dow6\", 1, timeanddate.dateToDayOfWeek(3, 1, 2022))\n    assert(\"dow7\", 4, timeanddate.dateToDayOfWeek(3, 1, 2024))\n\n    // Test Day Of Year\n    assert(\"doy1\", 1, timeanddate.dateToDayOfYear(1, 1, 2020))\n    assert(\"doy2\", 61, timeanddate.dateToDayOfYear(3, 1, 2020))\n    assert(\"doy3\", 366, timeanddate.dateToDayOfYear(12, 31, 2020))\n    assert(\"doy4\", 60, timeanddate.dateToDayOfYear(3, 1, 2021))\n    assert(\"doy5\", 365, timeanddate.dateToDayOfYear(12, 31, 2021))\n\n\n    // Test callbacks & numeric values \n\n    // Set date and let a minute pass to \"set\" old values\n    timeanddate.setDate(1, 1, 21)\n    timeanddate.set24HourTime(23, 59, 59)\n    basic.pause(2500)   // Rolls over to 0:00.00 on 1/2/21\n    timeanddate.set24HourTime(2, 22, 59)\n    basic.pause(2500)   // Rolls over to 2:23:02 on 1/2/21\n    // Day is 1, Hour is 2, minute is 22\n\n    clearCounters()  // Clear hours, minutes, days\n    timeanddate.setDate(4, 15, 21)\n    timeanddate.set24HourTime(23, 59, 59)\n    basic.pause(2500)   // + 1 to hours, minutes, days 0:00.02 on 4/16/20\n    assert(\"cb1\", 1, hours)\n    assert(\"cb2\", 1, minutes)\n    assert(\"cb3\", 1, days)\n\n\n    timeanddate.set24HourTime(0, 26, 58)\n    basic.pause(2500)  // One more to minutes\n    assert(\"cb4\", 1, hours)\n    assert(\"cb5\", 2, minutes)\n    assert(\"cb6\", 1, days)\n    timeanddate.set24HourTime(0, 59, 59)\n    basic.pause(2500)\n    assert(\"cb7\", 2, hours)\n    assert(\"cb8\", 3, minutes)\n    assert(\"cb9\", 1, days)\n\n    // Test time advancing and numericTime \n    timeanddate.setDate(4, 15, 21)\n    timeanddate.setTime(2, 5, 10, timeanddate.MornNight.AM)\n    timeanddate.advanceBy(10, timeanddate.TimeUnit.Seconds)  // a few seconds\n    timeanddate.numericTime(function (hour, minute, second, month, day, year) {\n        assert(\"adv+nt1a\", 20, second)\n        assert(\"adv+nt1b\", 2, hour)\n        assert(\"adv+nt1c\", 5, minute)\n        assert(\"adv+nt1d\", 4, month)\n        assert(\"adv+nt1e\", 15, day)\n        assert(\"adv+nt1f\", 21, year)\n    })\n\n    timeanddate.setDate(4, 15, 21)\n    timeanddate.setTime(2, 5, 10, timeanddate.MornNight.AM)\n    timeanddate.advanceBy(86405, timeanddate.TimeUnit.Seconds) // 1 day and 5 seconds\n    timeanddate.numericTime(function (hour, minute, second, month, day, year) {\n        assert(\"adv+nt2a\", 15, second)\n        assert(\"adv+nt2b\", 2, hour)\n        assert(\"adv+nt2c\", 5, minute)\n        assert(\"adv+nt2d\", 4, month)\n        assert(\"adv+nt2e\", 16, day)\n        assert(\"adv+nt2f\", 21, year)\n    })\n\n    timeanddate.setDate(4, 15, 21)\n    timeanddate.setTime(2, 5, 10, timeanddate.MornNight.AM)\n    timeanddate.advanceBy(45, timeanddate.TimeUnit.Days) // 45 days\n    timeanddate.numericTime(function (hour, minute, second, month, day, year) {\n        assert(\"adv+nt3a\", 5, month)\n        assert(\"adv+nt3b\", 30, day)\n        assert(\"adv+nt3c\", 21, year)\n    })\n\n    timeanddate.setDate(4, 15, 21)\n    timeanddate.setTime(2, 5, 10, timeanddate.MornNight.AM)\n    timeanddate.advanceBy(380, timeanddate.TimeUnit.Days) // 380 days\n    timeanddate.numericTime(function (hour, minute, second, month, day, year) {\n        assert(\"adv+nt4a\", 4, month)\n        assert(\"adv+nt4b\", 30, day)\n        assert(\"adv+nt4c\", 22, year)\n    })\n\n    testingDone()\n}\n\n/** Functinos to test running timer (long term tests) */\n\n// Reset time to 00:00:00 on AB\ninput.onButtonPressed(Button.AB, function () {\n    timeanddate.set24HourTime(0, 0, 0)\n    timeanddate.setDate(1, 1, 0)\n    basic.clearScreen()\n})\n\n// Show time on screen on A\ninput.onButtonPressed(Button.A, function () {\n    basic.showString(timeanddate.time(timeanddate.TimeFormat.HHMMSS24hr))\n})\n\n// Show time on UART on B\ninput.onButtonPressed(Button.B, function () {\n    serial.writeLine(\"time: \" + timeanddate.dateTime())\n}) \n\n"}}